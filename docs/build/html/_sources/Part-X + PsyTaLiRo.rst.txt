.. part-x documentation master file, created by
   sphinx-quickstart on Wed Jan  5 07:23:12 2022.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

Part-X + PsyTaLiRo
===================


Black-Box Function
------------------
The black-box function is the function for whom we need to find the falsifying behaviors. Below, we show to two examples.

1) A blackbox function can also be defined which can be used for checking against a certain specification using `PSY-TaLiRo 1.0.0a14 <https://sbtg.gitlab.io/psy-taliro/>`_.
Here, we define the Automatic Transmission Blackbox.

.. code-block:: python

   ...

   class AutotransModel(Model[AutotransDataT, None]):
      MODEL_NAME = "Autotrans_shift"

      def __init__(self) -> None:
         if not _has_matlab:
               raise RuntimeError(
                  "Simulink support requires the MATLAB Engine for Python to be installed"
               )

         engine = matlab.engine.start_matlab()
         # engine.addpath("examples")
         model_opts = engine.simget(self.MODEL_NAME)

         self.sampling_step = 0.05
         self.engine = engine
         self.model_opts = engine.simset(model_opts, "SaveFormat", "Array")

      def simulate(self, static: StaticInput, signals: Signals, intrvl: Interval) -> AutotransResultT:
         sim_t = matlab.double([0, intrvl.upper])
         n_times = (intrvl.length // self.sampling_step) + 2
         signal_times = np.linspace(intrvl.lower, intrvl.upper, int(n_times))
         signal_values = np.array([[signal.at_time(t) for t in signal_times] for signal in signals])

         model_input = matlab.double(np.row_stack((signal_times, signal_values)).T.tolist())
         
         timestamps, _, data = self.engine.sim(
               self.MODEL_NAME, sim_t, self.model_opts, model_input, nargout=3
         )

         timestamps_array = np.array(timestamps).flatten()
         data_array = np.array(data)

         return ModelData(data_array.T, timestamps_array)

Specification and Signals using Psy-TaLiRo:
-------------------------------------------

The Specification against which the signal are to be tested is written as follows:

.. code-block:: python

   AT1_phi = "G[0, 20] (speed <= 120)"
   specification = RTAMTDense(AT1_phi, {"speed": 0})

The Signal options are using psy-taliro. Below is an example:

In this example, we have two signals from time 0 to time 50. 

1. The first signal has 7 control points and the range for all the 7 control points are [0,100].

2. The second signal has 3 control points and the range for all the 3 control points are [0,325]:

.. code-block:: python

   signals = [
        SignalOptions(control_points = [(0, 100)]*7, signal_times=np.linspace(0.,50.,7)),
        SignalOptions(control_points = [(0, 325)]*3, signal_times=np.linspace(0.,50.,3)),
    ]


Parameters for Part-X
---------------------

The parameters that need to be defined for Part-X are mentioned below.
The usage of these parameters are defined in the :ref:`reference_examples`

- **BENCHMARK_NAME**: string
   Name of the benchmark

..

- **num_macro_rep**: int
   The number of replications

..

- **init_budget**: int
   The initiliazation budget of the algorithm. This refers to minimimum nunmber of samples that are required to be present in a region in order to generate samples from bayesian optimization and classify the region.

..

- **bo_budget**: int
   The number of samples that needs to be generated from Bayesian Optimization

..

- **cs_budget**: int
   The number of samples that must sampled from continuous sampling phase.

..

- **alpha**: float, [0,1]
   Region Classification percentile

..

- **R**: int
   The number of monte-carlo iterations. This is used in calculation of quantiles of a region.

..

- **M**: int
   The number of evaluation of per monte-carlo iteration. This is used in calculation of quantiles of a region.

..


- **delta**: float, int
   A number used to define the fraction of dimension, below which no further brnching in that dimension takes place. It is used for clsssificastion of a region.

..

- **fv_quantiles_for_gp** list
   List of values used for calculation at certain quantile values.

..



- **branching_factor**: int
   Number of sub-regions in which a region is branched. 

..

- **uniform_partitioning** True/False
   Wether to perform Uniform Partitioning or not. 

.. 

- **start_seed**: int
   Starting seed of the experiment to ensure reproducibility.

..

- **gpr_model**: The Gaussian Process Regressor model. Described in detail here.

..

- **bo_model**: The Bayesian Optimization model. Described in detail here.

..

- **init_sampling_type**: str
   Initial Sampling Algorithms. Defaults to "lhs_sampling". Can also use "uniform_sampling"
..

- **cs_sampling_type**: str
   Continued Sampling Mechanism. Defaults to "lhs_sampling". Can also use "uniform_sampling"
..

- **q_estim_sampling**: str
   Quantile estimation sampling Mechanism. Defaults to "lhs_sampling". Can also use "uniform_sampling"
..

- **mc_integral_sampling_type**: str
   Monte Carlo Integral Sampling Mechanism. Defaults to "lhs_sampling". Can also use "uniform_sampling"
..

- **results_sampling_type**: str
   Results Sampling Mechanism. Defaults to "lhs_sampling". Can also use "uniform_sampling"
..

- **results_at_confidence**: float
   Confidence level at which result to be computed
..

- **results_folder_name**: 
   Results folder name, 
..

- **num_cores**: int
   Number of cores to use. If value is 1, no parallalization is used. If value is greater than 1, various macro-replication will be spread over the cores.

It would be advisable to refer to Algorithm 1, 2, 3, 4 in the paper `Part-X <https://arxiv.org/pdf/2110.10729.pdf>`_ to get a deeper understanding of these paramters and where they are used.

Defining the Options from psy-taliro
------------------------------------

The maximum budget and evaluation time for signal are defined using psy-taliro options.

.. code-block:: python

   options = Options(runs=1, iterations=self.MAX_BUDGET, interval=(0, 50),  signals=self.signals)



Running the Optimizer
----------------------

Once the all of it defined, we can run the code. 

.. code-block:: python

   ...

   staliro(model, specification, optimizer, options)


Example - Running Part-X on AT1 Specification:
------------------------------------------------------

We define the model as follows:

.. code-block:: python

   import numpy as np
   from numpy.typing import NDArray
   from staliro.core.interval import Interval
   from staliro.core.model import Model, ModelData, Failure, StaticInput, Signals
   from staliro.options import Options, SignalOptions
   from staliro.specifications import RTAMTDense
   from staliro.staliro import staliro, simulate_model


   try:
      import matlab
      import matlab.engine
   except ImportError:
      _has_matlab = False
   else:
      _has_matlab = True

   AutotransDataT = NDArray[np.float_]
   AutotransResultT = ModelData[AutotransDataT, None]


   class AutotransModel(Model[AutotransDataT, None]):
      MODEL_NAME = "Autotrans_shift"

      def __init__(self) -> None:
         if not _has_matlab:
               raise RuntimeError(
                  "Simulink support requires the MATLAB Engine for Python to be installed"
               )

         engine = matlab.engine.start_matlab()
         # engine.addpath("examples")
         model_opts = engine.simget(self.MODEL_NAME)

         self.sampling_step = 0.05
         self.engine = engine
         self.model_opts = engine.simset(model_opts, "SaveFormat", "Array")

      def simulate(self, static: StaticInput, signals: Signals, intrvl: Interval) -> AutotransResultT:
         sim_t = matlab.double([0, intrvl.upper])
         n_times = (intrvl.length // self.sampling_step) + 2
         signal_times = np.linspace(intrvl.lower, intrvl.upper, int(n_times))
         signal_values = np.array([[signal.at_time(t) for t in signal_times] for signal in signals])

         model_input = matlab.double(np.row_stack((signal_times, signal_values)).T.tolist())
         
         timestamps, _, data = self.engine.sim(
               self.MODEL_NAME, sim_t, self.model_opts, model_input, nargout=3
         )

         timestamps_array = np.array(timestamps).flatten()
         data_array = np.array(data)

         return ModelData(data_array.T, timestamps_array)


We then run part-X as follows:

.. code-block:: python 

   # Import All the necessary packges
   
   from AT_benchmark.AT_specifications import load_specification_dict
   from models import AutotransModel
   from Benchmark import Benchmark
   from partxv2.partxInterface.staliroIntegration import PartX
   from partxv2.bayesianOptimization.internalBO import InternalBO
   from partxv2.gprInterface.internalGPR import InternalGPR

   from staliro.staliro import staliro
   from staliro.options import Options

   # Define Signals and Specification
   benchmark = "AT1"
   results_folder = "Arch_Partx_Demo"

   AT1_phi = "G[0, 20] (speed <= 120)"
   specification = RTAMTDense(AT1_phi, {"speed": 0})
  
   signals = [
         SignalOptions(control_points = [(0, 100)]*7, signal_times=np.linspace(0.,50.,7)),
         SignalOptions(control_points = [(0, 325)]*3, signal_times=np.linspace(0.,50.,3)),
      ]

   MAX_BUDGET = 2000
   NUMBER_OF_MACRO_REPLICATIONS = 10
   
   model = AutotransModel()
   optimizer = PartX(
            BENCHMARK_NAME=f"{benchmark}_budget_{MAX_BUDGET}_{NUMBER_OF_MACRO_REPLICATIONS}_reps",
            num_macro_reps = NUMBER_OF_MACRO_REPLICATIONS,
            init_budget = 20,
            bo_budget = 10,
            cs_budget = 20,
            alpha=0.05,
            R = 20,
            M = 500,
            delta=0.001,
            fv_quantiles_for_gp=[0.5,0.05,0.01],
            branching_factor = 2,
            uniform_partitioning = True,
            seed = 12345,
            gpr_model = InternalGPR(),
            bo_model = InternalBO(),
            init_sampling_type = "lhs_sampling",
            cs_sampling_type = "lhs_sampling",
            q_estim_sampling = "lhs_sampling",
            mc_integral_sampling_type = "uniform_sampling",
            results_sampling_type = "uniform_sampling",
            results_at_confidence = 0.95,
            results_folder_name = results_folder,
            num_cores = 1,
      )

   options = Options(runs=1, iterations=MAX_BUDGET, interval=(0, 50),  signals=signals)

   
   result = staliro(model, specification, optimizer, options)

