
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Standalone Usage &#8212; Part-X  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Part-X with PsyTaLiRo" href="Part-X%20with%20PsyTaLiRo.html" />
    <link rel="prev" title="Getting Started" href="Getting%20Started.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="standalone-usage">
<h1>Standalone Usage<a class="headerlink" href="#standalone-usage" title="Permalink to this heading">¶</a></h1>
<p>To run Part-X, we need a black-box function, and oracle function and to define various parameters of Part-X.</p>
<section id="black-box-function">
<h2>Black-Box Function<a class="headerlink" href="#black-box-function" title="Permalink to this heading">¶</a></h2>
<p>The black-box function is the function for whom we need to find the falsifying behaviors. Below, we show to two examples.</p>
<blockquote>
<div><p>The non-linear, non-convex Himmelblaus Function can be defined as follows:</p>
</div></blockquote>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_function</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
   <span class="k">return</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">11</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">7</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">40</span>
</pre></div>
</div>
</section>
<section id="oracle-function">
<span id="reference-oracle-function"></span><h2>Oracle Function<a class="headerlink" href="#oracle-function" title="Permalink to this heading">¶</a></h2>
<p>The oracle function is the function which defines feasible and infeasible points that can be sampled by the Part-X algorithm. The oracle function takes in a pot and returns a boolean value to indicate if the point is feasible or infeasible.</p>
<p>Here is an example of simple constraint</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">oracle_function</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
   <span class="k">return</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">&gt;</span> <span class="mf">0.5</span>
</pre></div>
</div>
<p>If there are no constraints, you can define the oracle function as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">oracle_function</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
   <span class="k">return</span> <span class="kc">True</span>
</pre></div>
</div>
</section>
<section id="defining-gpr-model">
<span id="reference-gpr-definition-standalone"></span><h2>Defining GPR Model<a class="headerlink" href="#defining-gpr-model" title="Permalink to this heading">¶</a></h2>
<p>The Gaussian Process Regressor(GPR) is an essential part of the Part-X algorithm.
While one can choose the internal GPR model by importing it:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">partx.gprInterface</span> <span class="kn">import</span> <span class="n">InternalGPR</span>
<span class="n">gpr_model</span> <span class="o">=</span> <span class="n">InternalGPR</span><span class="p">()</span>
</pre></div>
</div>
<p>This <em>gpr_model</em> can be passed to Part-X algorithm.</p>
<p>However, we even provide a way for users to use their own GPR.</p>
<p>To use this, the user has to import the GPR interface and write their GPR model as shown below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">.gprInterface</span> <span class="kn">import</span> <span class="n">GaussianProcessRegressorStructure</span>
<span class="kn">from</span> <span class="nn">sklearn.gaussian_process</span> <span class="kn">import</span> <span class="n">GaussianProcessRegressor</span>
<span class="kn">from</span> <span class="nn">sklearn.gaussian_process.kernels</span> <span class="kn">import</span> <span class="n">Matern</span><span class="p">,</span> <span class="n">ConstantKernel</span><span class="p">,</span> <span class="n">RBF</span><span class="p">,</span> <span class="n">WhiteKernel</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">fmin_l_bfgs_b</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">catch_warnings</span>
<span class="kn">import</span> <span class="nn">warnings</span>


<span class="k">def</span> <span class="nf">optimizer_lbfgs_b</span><span class="p">(</span><span class="n">obj_func</span><span class="p">,</span> <span class="n">initial_theta</span><span class="p">):</span>
   <span class="k">with</span> <span class="n">catch_warnings</span><span class="p">():</span>
      <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
      <span class="n">params</span> <span class="o">=</span> <span class="n">fmin_l_bfgs_b</span><span class="p">(</span>
            <span class="n">obj_func</span><span class="p">,</span> <span class="n">initial_theta</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">30000</span><span class="p">,</span> <span class="n">maxfun</span><span class="o">=</span><span class="mf">1e10</span>
      <span class="p">)</span>
   <span class="k">return</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">UserDefinedGPR</span><span class="p">(</span><span class="n">GaussianProcessRegressorStructure</span><span class="p">):</span>
   <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">random_state</span> <span class="o">=</span> <span class="mi">12345</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">gpr_model</span> <span class="o">=</span> <span class="n">GaussianProcessRegressor</span><span class="p">(</span>
            <span class="n">kernel</span><span class="o">=</span><span class="n">Matern</span><span class="p">(</span><span class="n">nu</span><span class="o">=</span><span class="mf">2.5</span><span class="p">),</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">normalize_y</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">n_restarts_optimizer</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
      <span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>

   <span class="k">def</span> <span class="nf">fit_gpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&quot;&quot;&quot;Method to fit gpr Model</span>

<span class="sd">      Args:</span>
<span class="sd">            x_train: Samples from Training set.</span>
<span class="sd">            y_train: Evaluated values of samples from Trainig set.</span>


<span class="sd">      &quot;&quot;&quot;</span>
      <span class="n">X_scaled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

      <span class="k">with</span> <span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gpr_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>

   <span class="k">def</span> <span class="nf">predict_gpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&quot;&quot;&quot;Method to predict mean and std_dev from gpr model</span>

<span class="sd">      Args:</span>
<span class="sd">            x_train: Samples from Training set.</span>


<span class="sd">      Returns:</span>
<span class="sd">            mean</span>
<span class="sd">            std_dev</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="n">x_scaled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
      <span class="k">with</span> <span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
            <span class="n">yPred</span><span class="p">,</span> <span class="n">predSigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gpr_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x_scaled</span><span class="p">,</span> <span class="n">return_std</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">yPred</span><span class="p">,</span> <span class="n">predSigma</span>
</pre></div>
</div>
</section>
<section id="defining-bayesian-optimization-model">
<span id="reference-bo-definition-standalone"></span><h2>Defining Bayesian Optimization Model<a class="headerlink" href="#defining-bayesian-optimization-model" title="Permalink to this heading">¶</a></h2>
<p>Like the GPR, the Bayesian Optimization (BO) is also an essential part of the Part-X algorithm.
While one can choose the internal BO model by importing it:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">partx.bayesianOptimization</span> <span class="kn">import</span> <span class="n">InternalBO</span>
<span class="n">bo_model</span> <span class="o">=</span> <span class="n">InternalBO</span><span class="p">()</span>
</pre></div>
</div>
<p>This <em>bo_model</em> can be passed to Part-X algorithm.</p>
<p>However, we even provide a way for users to use their own BO code. The idea is that the user can plug in the existing BO implementation for an implementatin such that it returns a single new point.</p>
<p>To use this, the user has to import the BO interface and write their BO model as shown below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Tuple</span>
 <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
 <span class="kn">from</span> <span class="nn">numpy.typing</span> <span class="kn">import</span> <span class="n">NDArray</span>
 <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>
 <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">norm</span>

 <span class="kn">from</span> <span class="nn">.bointerface</span> <span class="kn">import</span> <span class="n">BO_Interface</span>
 <span class="kn">from</span> <span class="nn">..gprInterface</span> <span class="kn">import</span> <span class="n">GPR</span>
 <span class="kn">from</span> <span class="nn">..sampling</span> <span class="kn">import</span> <span class="n">uniform_sampling</span>

 <span class="k">class</span> <span class="nc">InternalBO</span><span class="p">(</span><span class="n">BO_Interface</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
       <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span>
       <span class="bp">self</span><span class="p">,</span>
       <span class="n">x_train</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span>
       <span class="n">y_train</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span>
       <span class="n">region_support</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span>
       <span class="n">gpr_model</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
       <span class="n">oracle_info</span><span class="p">,</span>
       <span class="n">rng</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">NDArray</span><span class="p">]:</span>

<span class="w">       </span><span class="sd">&quot;&quot;&quot;Internal BO Model</span>

<span class="sd">       Args:</span>
<span class="sd">             x_train: Samples from Training set.</span>
<span class="sd">             y_train: Evaluated values of samples from Trainig set.</span>
<span class="sd">             region_support: Min and Max of all dimensions</span>
<span class="sd">             gpr_model: Gaussian Process Regressor Model developed using Factory</span>
<span class="sd">             oracle_info: Oracle defining the constraints.</span>
<span class="sd">             rng: RNG object from numpy</span>

<span class="sd">       Raises:</span>
<span class="sd">             TypeError: If x_train is not 2 dimensional numpy array or does not match dimensions</span>
<span class="sd">             TypeError: If y_train is not (n,) numpy array</span>
<span class="sd">             TypeError: If there is a mismatch between x_train and y_train</span>

<span class="sd">       Returns:</span>
<span class="sd">             x_new</span>
<span class="sd">       &quot;&quot;&quot;</span>

       <span class="n">model</span> <span class="o">=</span> <span class="n">GPR</span><span class="p">(</span><span class="n">gpr_model</span><span class="p">)</span>
       <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

       <span class="n">pred_sample_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opt_acquisition</span><span class="p">(</span><span class="n">y_train</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">region_support</span><span class="p">,</span> <span class="n">oracle_info</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>


       <span class="k">return</span> <span class="n">pred_sample_x</span>

    <span class="k">def</span> <span class="nf">_opt_acquisition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y_train</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span> <span class="n">gpr_model</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">region_support</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span> <span class="n">oracle_info</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">:</span>
<span class="w">       </span><span class="sd">&quot;&quot;&quot;Get the sample points</span>

<span class="sd">       Args:</span>
<span class="sd">             X: sample points</span>
<span class="sd">             y: corresponding robustness values</span>
<span class="sd">             model: the GP models</span>
<span class="sd">             sbo: sample points to construct the robustness values</span>
<span class="sd">             test_function_dimension: The dimensionality of the region. (Dimensionality of the test function)</span>
<span class="sd">             region_support: The bounds of the region within which the sampling is to be done.</span>
<span class="sd">                                        Region Bounds is M x N x O where;</span>
<span class="sd">                                           M = number of regions;</span>
<span class="sd">                                           N = test_function_dimension (Dimensionality of the test function);</span>
<span class="sd">                                           O = Lower and Upper bound. Should be of length 2;</span>

<span class="sd">       Returns:</span>
<span class="sd">             The new sample points by BO</span>
<span class="sd">       &quot;&quot;&quot;</span>

       <span class="n">tf_dim</span> <span class="o">=</span> <span class="n">region_support</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
       <span class="n">lower_bound_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">region_support</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
       <span class="n">upper_bound_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">region_support</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>

       <span class="n">curr_best</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y_train</span><span class="p">)</span>

       <span class="c1"># bnds = Bounds(lower_bound_theta, upper_bound_theta)</span>
       <span class="n">fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x_</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_acquisition</span><span class="p">(</span><span class="n">y_train</span><span class="p">,</span> <span class="n">x_</span><span class="p">,</span> <span class="n">gpr_model</span><span class="p">)</span>

       <span class="n">random_samples</span> <span class="o">=</span> <span class="n">uniform_sampling</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="n">region_support</span><span class="p">,</span> <span class="n">tf_dim</span><span class="p">,</span> <span class="n">oracle_info</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>
       <span class="n">min_bo_val</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_acquisition</span><span class="p">(</span>
             <span class="n">y_train</span><span class="p">,</span> <span class="n">random_samples</span><span class="p">,</span> <span class="n">gpr_model</span><span class="p">,</span> <span class="s2">&quot;multiple&quot;</span>
       <span class="p">)</span>

       <span class="n">min_bo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">random_samples</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">min_bo_val</span><span class="p">),</span> <span class="p">:])</span>
       <span class="n">min_bo_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">min_bo_val</span><span class="p">)</span>

       <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">):</span>
             <span class="n">new_params</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span>
                <span class="n">fun</span><span class="p">,</span>
                <span class="n">bounds</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">lower_bound_theta</span><span class="p">,</span> <span class="n">upper_bound_theta</span><span class="p">)),</span>
                <span class="n">x0</span><span class="o">=</span><span class="n">min_bo</span><span class="p">,</span>
             <span class="p">)</span>

             <span class="k">if</span> <span class="ow">not</span> <span class="n">new_params</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
                <span class="k">continue</span>

             <span class="k">if</span> <span class="n">min_bo</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">fun</span><span class="p">(</span><span class="n">new_params</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_bo_val</span><span class="p">:</span>
                <span class="n">min_bo</span> <span class="o">=</span> <span class="n">new_params</span><span class="o">.</span><span class="n">x</span>
                <span class="n">min_bo_val</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="n">min_bo</span><span class="p">)</span>
       <span class="n">new_params</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span>
             <span class="n">fun</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">lower_bound_theta</span><span class="p">,</span> <span class="n">upper_bound_theta</span><span class="p">)),</span> <span class="n">x0</span><span class="o">=</span><span class="n">min_bo</span>
       <span class="p">)</span>
       <span class="n">min_bo</span> <span class="o">=</span> <span class="n">new_params</span><span class="o">.</span><span class="n">x</span>

       <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">min_bo</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_surrogate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gpr_model</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">x_train</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">):</span>
<span class="w">       </span><span class="sd">&quot;&quot;&quot;_surrogate Model function</span>

<span class="sd">       Args:</span>
<span class="sd">             model: Gaussian process model</span>
<span class="sd">             X: Input points</span>

<span class="sd">       Returns:</span>
<span class="sd">             Predicted values of points using gaussian process model</span>
<span class="sd">       &quot;&quot;&quot;</span>

       <span class="k">return</span> <span class="n">gpr_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x_train</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_acquisition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y_train</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span> <span class="n">sample</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span> <span class="n">gpr_model</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">sample_type</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span><span class="s2">&quot;single&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">:</span>
<span class="w">       </span><span class="sd">&quot;&quot;&quot;Acquisition Model: Expected Improvement</span>

<span class="sd">       Args:</span>
<span class="sd">             y_train: corresponding robustness values</span>
<span class="sd">             sample: Sample(s) whose EI is to be calculated</span>
<span class="sd">             gpr_model: GPR model</span>
<span class="sd">             sample_type: Single sample or list of model. Defaults to &quot;single&quot;. other options is &quot;multiple&quot;.</span>

<span class="sd">       Returns:</span>
<span class="sd">             EI of samples</span>
<span class="sd">       &quot;&quot;&quot;</span>
       <span class="n">curr_best</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y_train</span><span class="p">)</span>

       <span class="k">if</span> <span class="n">sample_type</span> <span class="o">==</span> <span class="s2">&quot;multiple&quot;</span><span class="p">:</span>
             <span class="n">mu</span><span class="p">,</span> <span class="n">std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_surrogate</span><span class="p">(</span><span class="n">gpr_model</span><span class="p">,</span> <span class="n">sample</span><span class="p">)</span>
             <span class="n">ei_list</span> <span class="o">=</span> <span class="p">[]</span>
             <span class="k">for</span> <span class="n">mu_iter</span><span class="p">,</span> <span class="n">std_iter</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">std</span><span class="p">):</span>
                <span class="n">pred_var</span> <span class="o">=</span> <span class="n">std_iter</span>
                <span class="k">if</span> <span class="n">pred_var</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                   <span class="n">var_1</span> <span class="o">=</span> <span class="n">curr_best</span> <span class="o">-</span> <span class="n">mu_iter</span>
                   <span class="n">var_2</span> <span class="o">=</span> <span class="n">var_1</span> <span class="o">/</span> <span class="n">pred_var</span>

                   <span class="n">ei</span> <span class="o">=</span> <span class="p">(</span><span class="n">var_1</span> <span class="o">*</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">var_2</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span>
                         <span class="n">pred_var</span> <span class="o">*</span> <span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">var_2</span><span class="p">)</span>
                   <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                   <span class="n">ei</span> <span class="o">=</span> <span class="mf">0.0</span>

                <span class="n">ei_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ei</span><span class="p">)</span>
             <span class="c1"># print(np.array(ei_list).shape)</span>
             <span class="c1"># print(&quot;*****&quot;)</span>
             <span class="c1"># return np.array(ei_list)</span>
       <span class="k">elif</span> <span class="n">sample_type</span> <span class="o">==</span> <span class="s2">&quot;single&quot;</span><span class="p">:</span>
             <span class="c1"># print(&quot;kfkf&quot;)</span>
             <span class="n">mu</span><span class="p">,</span> <span class="n">std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_surrogate</span><span class="p">(</span><span class="n">gpr_model</span><span class="p">,</span> <span class="n">sample</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
             <span class="n">pred_var</span> <span class="o">=</span> <span class="n">std</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
             <span class="k">if</span> <span class="n">pred_var</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">var_1</span> <span class="o">=</span> <span class="n">curr_best</span> <span class="o">-</span> <span class="n">mu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">var_2</span> <span class="o">=</span> <span class="n">var_1</span> <span class="o">/</span> <span class="n">pred_var</span>

                <span class="n">ei</span> <span class="o">=</span> <span class="p">(</span><span class="n">var_1</span> <span class="o">*</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">var_2</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span>
                   <span class="n">pred_var</span> <span class="o">*</span> <span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">var_2</span><span class="p">)</span>
                <span class="p">)</span>
             <span class="k">else</span><span class="p">:</span>
                <span class="n">ei</span> <span class="o">=</span> <span class="mf">0.0</span>
             <span class="c1"># return ei</span>

       <span class="k">if</span> <span class="n">sample_type</span> <span class="o">==</span> <span class="s2">&quot;multiple&quot;</span><span class="p">:</span>
             <span class="n">return_ei</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ei_list</span><span class="p">)</span>
       <span class="k">elif</span> <span class="n">sample_type</span> <span class="o">==</span> <span class="s2">&quot;single&quot;</span><span class="p">:</span>
             <span class="n">return_ei</span> <span class="o">=</span> <span class="n">ei</span>

       <span class="k">return</span> <span class="n">return_ei</span>
</pre></div>
</div>
</section>
<section id="parameters">
<h2>Parameters<a class="headerlink" href="#parameters" title="Permalink to this heading">¶</a></h2>
<p>The parameters that need to be defined for Part-X are mentioned below.
The usage of these parameters are defined in the <span class="xref std std-ref">reference_examples</span></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>BENCHMARK_NAME</strong>: string</dt><dd><p>Name of the benchmark</p>
</dd>
</dl>
</li>
</ul>
<ul class="simple">
<li><dl class="simple">
<dt><strong>test_function</strong>: function</dt><dd><p>The black-box test function</p>
</dd>
</dl>
</li>
</ul>
<ul class="simple">
<li><dl class="simple">
<dt><strong>oracle_function</strong>: function</dt><dd><p>The oracle function</p>
</dd>
</dl>
</li>
</ul>
<ul class="simple">
<li><dl class="simple">
<dt><strong>num_macro_rep</strong>: int</dt><dd><p>The number of replications</p>
</dd>
</dl>
</li>
</ul>
<ul>
<li><dl>
<dt><strong>init_reg_sup</strong>: 2-d Numpy Array</dt><dd><p>Needs to be a 3-dimensional list that represents the initial region support of the function.
For exmples:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">region_support</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
</pre></div>
</div>
<p>Here, the first dimension has the range [-5,5], the second dimension has the range [-2,3] and theird dimension has the range [-3,4]</p>
</dd>
</dl>
</li>
</ul>
<ul class="simple">
<li><dl class="simple">
<dt><strong>tf_dim</strong>: int</dt><dd><p>Needs to be an interger that represents the dimensionality of the blask-box function</p>
</dd>
</dl>
</li>
</ul>
<ul class="simple">
<li><dl class="simple">
<dt><strong>max_budget</strong>: int</dt><dd><p>The maximum budget or the maximum number of evaluations of the black-box function that are allowed.</p>
</dd>
</dl>
</li>
</ul>
<ul class="simple">
<li><dl class="simple">
<dt><strong>init_budget</strong>: int</dt><dd><p>The initiliazation budget of the algorithm. This refers to minimimum nunmber of samples that are required to be present in a region in order to generate samples from bayesian optimization and classify the region.</p>
</dd>
</dl>
</li>
</ul>
<ul class="simple">
<li><dl class="simple">
<dt><strong>bo_budget</strong>: int</dt><dd><p>The number of samples that needs to be generated from Bayesian Optimization</p>
</dd>
</dl>
</li>
</ul>
<ul class="simple">
<li><dl class="simple">
<dt><strong>cs_budget</strong>: int</dt><dd><p>The number of samples that must sampled from continuous sampling phase.</p>
</dd>
</dl>
</li>
</ul>
<ul class="simple">
<li><dl class="simple">
<dt><strong>n_tries_randomsampling</strong>: int</dt><dd><p>The number of tries a point should be sampled again to follow constraints in the random sampling phase. In case of no no constraint, set the value to 1. An error is raised if the number of tries is exhausted.</p>
</dd>
</dl>
</li>
</ul>
<ul class="simple">
<li><dl class="simple">
<dt><strong>n_tries_BO</strong>: int</dt><dd><p>The number of tries a point should be sampled again to follow constraints in the BO sampling phase. In case of no constraint, set the value to 1. If th number of tries is exhausted, a random feasible point is selected.</p>
</dd>
</dl>
</li>
</ul>
<ul class="simple">
<li><dl class="simple">
<dt><strong>alpha</strong>: float, [0,1]</dt><dd><p>Region Classification percentile</p>
</dd>
</dl>
</li>
</ul>
<ul class="simple">
<li><dl class="simple">
<dt><strong>R</strong>: int</dt><dd><p>The number of monte-carlo iterations. This is used in calculation of quantiles of a region.</p>
</dd>
</dl>
</li>
</ul>
<ul class="simple">
<li><dl class="simple">
<dt><strong>M</strong>: int</dt><dd><p>The number of evaluation of per monte-carlo iteration. This is used in calculation of quantiles of a region.</p>
</dd>
</dl>
</li>
</ul>
<ul class="simple">
<li><dl class="simple">
<dt><strong>delta</strong>: float, int</dt><dd><p>A number used to define the fraction of dimension, below which no further brnching in that dimension takes place. It is used for clsssificastion of a region.</p>
</dd>
</dl>
</li>
</ul>
<ul class="simple">
<li><dl class="simple">
<dt><strong>fv_quantiles_for_gp</strong> list</dt><dd><p>List of values used for calculation at certain quantile values.</p>
</dd>
</dl>
</li>
</ul>
<ul class="simple">
<li><dl class="simple">
<dt><strong>branching_factor</strong>: int</dt><dd><p>Number of sub-regions in which a region is branched.</p>
</dd>
</dl>
</li>
</ul>
<ul class="simple">
<li><dl class="simple">
<dt><strong>uniform_partitioning</strong> True/False</dt><dd><p>Wether to perform Uniform Partitioning or not.</p>
</dd>
</dl>
</li>
</ul>
<ul class="simple">
<li><dl class="simple">
<dt><strong>start_seed</strong>: int</dt><dd><p>Starting seed of the experiment to ensure reproducibility.</p>
</dd>
</dl>
</li>
</ul>
<ul class="simple">
<li><p><strong>gpr_model</strong>: The Gaussian Process Regressor model. Described in detail <span class="xref std std-ref">_reference_gpr_definition_standalone</span> .</p></li>
</ul>
<ul class="simple">
<li><p><strong>bo_model</strong>: The Bayesian Optimization model. Described in detail <span class="xref std std-ref">_reference_bo_definition_standalone</span> .</p></li>
</ul>
<ul class="simple">
<li><dl class="simple">
<dt><strong>init_sampling_type</strong>: str</dt><dd><p>Initial Sampling Algorithms. Defaults to “lhs_sampling”. Can also use “uniform_sampling”</p>
</dd>
</dl>
</li>
</ul>
<ul class="simple">
<li><dl class="simple">
<dt><strong>cs_sampling_type</strong>: str</dt><dd><p>Continued Sampling Mechanism. Defaults to “lhs_sampling”. Can also use “uniform_sampling”</p>
</dd>
</dl>
</li>
</ul>
<ul class="simple">
<li><dl class="simple">
<dt><strong>q_estim_sampling</strong>: str</dt><dd><p>Quantile estimation sampling Mechanism. Defaults to “lhs_sampling”. Can also use “uniform_sampling”</p>
</dd>
</dl>
</li>
</ul>
<ul class="simple">
<li><dl class="simple">
<dt><strong>mc_integral_sampling_type</strong>: str</dt><dd><p>Monte Carlo Integral Sampling Mechanism. Defaults to “lhs_sampling”. Can also use “uniform_sampling”</p>
</dd>
</dl>
</li>
</ul>
<ul class="simple">
<li><dl class="simple">
<dt><strong>results_sampling_type</strong>: str</dt><dd><p>Results Sampling Mechanism. Defaults to “lhs_sampling”. Can also use “uniform_sampling”</p>
</dd>
</dl>
</li>
</ul>
<ul class="simple">
<li><dl class="simple">
<dt><strong>results_at_confidence</strong>: float</dt><dd><p>Confidence level at which result to be computed</p>
</dd>
</dl>
</li>
</ul>
<ul class="simple">
<li><dl class="simple">
<dt><strong>results_folder_name</strong>:</dt><dd><p>Results folder name,</p>
</dd>
</dl>
</li>
</ul>
<ul class="simple">
<li><dl class="simple">
<dt><strong>num_cores</strong>: int</dt><dd><p>Number of cores to use. If value is 1, no parallalization is used. If value is greater than 1, various macro-replication will be spread over the cores.</p>
</dd>
</dl>
</li>
</ul>
<p>It would be advisable to refer to Algorithm 1, 2, 3, 4 in the paper <a class="reference external" href="https://arxiv.org/pdf/2110.10729.pdf">Part-X</a> to get a deeper understanding of these paramters and where they are used.</p>
</section>
<section id="running-the-optimizer">
<h2>Running the Optimizer<a class="headerlink" href="#running-the-optimizer" title="Permalink to this heading">¶</a></h2>
<p>Once the black-box function and the parameters are defined, we can run the code.</p>
<p>If we are using psy-staliro and passing the Part-X as an optimizer, we csn define the parameters as follows and pass them as options to psy-staliro.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>

<span class="kn">from</span> <span class="nn">partx.partxInterface</span> <span class="kn">import</span> <span class="n">run_partx</span>

<span class="n">run_partx</span><span class="p">(</span><span class="n">BENCHMARK_NAME</span><span class="p">,</span>
         <span class="n">test_function</span><span class="p">,</span>
         <span class="n">oracle_function</span><span class="p">,</span>
         <span class="n">num_macro_reps</span><span class="p">,</span>
         <span class="n">init_reg_sup</span><span class="p">,</span>
         <span class="n">tf_dim</span><span class="p">,</span>
         <span class="n">max_budget</span><span class="p">,</span>
         <span class="n">init_budget</span><span class="p">,</span>
         <span class="n">bo_budget</span><span class="p">,</span>
         <span class="n">cs_budget</span><span class="p">,</span>
         <span class="n">n_tries_randomsampling</span><span class="p">,</span>
         <span class="n">n_tries_BO</span><span class="p">,</span>
         <span class="n">alpha</span><span class="p">,</span>
         <span class="n">R</span><span class="p">,</span>
         <span class="n">M</span><span class="p">,</span>
         <span class="n">delta</span><span class="p">,</span>
         <span class="n">fv_quantiles_for_gp</span><span class="p">,</span>
         <span class="n">branching_factor</span><span class="p">,</span>
         <span class="n">uniform_partitioning</span><span class="p">,</span>
         <span class="n">start_seed</span><span class="p">,</span>
         <span class="n">gpr_model</span><span class="p">,</span>
         <span class="n">bo_model</span><span class="p">,</span>
         <span class="n">init_sampling_type</span><span class="p">,</span>
         <span class="n">cs_sampling_type</span><span class="p">,</span>
         <span class="n">q_estim_sampling</span><span class="p">,</span>
         <span class="n">mc_integral_sampling_type</span><span class="p">,</span>
         <span class="n">results_sampling_type</span><span class="p">,</span>
         <span class="n">results_at_confidence</span><span class="p">,</span>
         <span class="n">results_folder_name</span><span class="p">,</span>
         <span class="n">num_cores</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Part-X</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="Getting%20Started.html">Getting Started</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Getting%20Started.html#installation">Installation</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="Getting%20Started.html#basic-usage">Basic Usage</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Standalone Usage</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#black-box-function">Black-Box Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="#oracle-function">Oracle Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="#defining-gpr-model">Defining GPR Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="#defining-bayesian-optimization-model">Defining Bayesian Optimization Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="#parameters">Parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="#running-the-optimizer">Running the Optimizer</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Part-X%20with%20PsyTaLiRo.html">Part-X with PsyTaLiRo</a></li>
<li class="toctree-l1"><a class="reference internal" href="Outputs.html">Outputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="Demo%201%20-%20Standalone%20Part-X.html">Demo 1 - Standalone Part-X</a></li>
<li class="toctree-l1"><a class="reference internal" href="Demo%202%20-%20Part-X%20with%20Psy-TaLiRo.html">Demo 2 - Part-X with Psy-TaLiRo</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  <li><a href="Getting%20Started.html">Getting Started</a><ul>
      <li>Previous: <a href="Getting%20Started.html" title="previous chapter">Getting Started</a></li>
      <li>Next: <a href="Part-X%20with%20PsyTaLiRo.html" title="next chapter">Part-X with PsyTaLiRo</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Tanmay Bhaskar Khandait.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="_sources/Standalone Usage.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>